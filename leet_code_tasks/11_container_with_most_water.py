"""
11. Container With Most Water

Простым языком:
Представьте, что у вас есть вертикальные линии разной высоты, поставленные на оси X.
Например, массив height = [1, 8, 6, 2, 5, 4, 8, 3, 7] означает, что:
    на позиции 0 высота линии — 1,
    на позиции 1 — 8,
    на позиции 2 — 6 и т.д.

Что нужно сделать?
Найти две линии (например, на позициях i и j), чтобы вместе с осью X они образовали сосуд, в котором максимально воды.

Как считается количество воды?

Ширина сосуда = расстояние между линиями = |j - i|.
Высота сосуда = минимальная из двух высот (потому что вода льётся из самой низкой линии).
Объём воды = ширина × высота.
Пример:
Для height = [1, 8, 6, 2, 5, 4, 8, 3, 7]:

Возьмём линии на позициях 1 (высота 8) и 8 (высота 7).
Ширина = 8 - 1 = 7.
Высота = min(8, 7) = 7.
Объём = 7 × 7 = 49.
Важно:

Сосуд не может быть наклонён (только прямоугольник).
Нужно найти максимальный объём воды.
"""
from typing import List

test_data = (
    # heights, expected_volume
    ([1,8,6,2,5,4,8,3,7], 49),
    ([1,1], 1),
    ([10, 1, 1, 1, 1, 10], 50),
    ([3, 1, 2, 4, 1], 9),
    ([1, 2, 3, 4, 5], 6),
    ([5, 4, 5, 3, 2], 10),
)

def max_volume(height_arr: List[int]) -> int:
    """
    Будем использовать метод двух указателей для расчета объема воды между двумя линиями.
    Один указатель будет двигаться по массиву height_arr слева направо, а второй наоборот справа налево.
    """
    left, right = 0, len(height_arr) - 1    # Левый указатель начнет сначала массива, а правый с конца
    max_water = 0  # ячейка для хранения максимального объема воды

    # Цикл остановиться, когда left сравняется с right.
    # Это будет значить, что очередная итерация не даст линий, которые можно представить как сосуд для воды,
    # так как оба указателя покажут одну и ту же линию.
    # А также все последующие итерации не имеют смысла, ведь там, куда пойдет left уже прошел right,
    # а right пойдет по тем же линиями, на которых уже побывал left. Короче, получится то, что мы уже посчитали.
    while left < right:

        # Рассчитываем объем воды между двумя линиями
        container_width = right - left  # Ширина сосуда с водой
        container_height = min(height_arr[left], height_arr[right])     # Высота сосуда - минимальная высота двух линий
        i_volume = container_width * container_height   # Объем воды в сосуде - произведение ширины на высоту

        # Присваиваем максимальный объем воды
        max_water = max(max_water, i_volume)

        # Сдвигаем указатели:
        # Двигаем тот указатель, который остановился на линии с меньшей высотой
        if height_arr[left] < height_arr[right]: left += 1  # Если ниже левая линия, то left двигаем вправо
        else: right -= 1    # Иначе, если меньше правая линия, или они равны, то двигаем right влево
        # Общий смысл здесь в том, что мы вынуждено уменьшаем ширину сосуда (это важное значение для объема,
        # чем она больше, тем больше и объем) с той единственной целью, чтобы подобрать лучшие условия.
        # Сужать ширину - это вынужденный шаг. Из этого следует, что было бы глупо сужать ширину с того края сосуда,
        # где выше его стенка (стенки сосуда left и right - это еще одни переменные от которых зависит объем).
        # Поэтому мы идем на этот вынужденный шаг сужения ширины с целью найти стенку повыше.
        # Вот и получается, что если справа у нас пока что была самая высокая стенка сосуда, а слева ниже, то надо
        # что-то менять с левой стенкой и с той стороны сужать ширину сосуда.

    return max_water


for i_arr, i_res in test_data:
    result = max_volume(i_arr)
    if result == i_res: print("ВЕРНО", i_arr, i_res, result)
    else: print("NOT ВЕРНО", i_arr, i_res, result)

