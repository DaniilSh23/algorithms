"""
LeetCode # 15: "3Sum".
У вас есть список чисел (например, [-1, 0, 1, 2, -1, -4]). Нужно найти все тройки чисел из этого списка, которые в
сумме дают 0, при условии:

Три разных числа (но они могут быть одинаковыми по значению, если они на разных позициях).
Нельзя использовать одно и то же число дважды (например, нельзя взять элемент на позиции 0 два раза).
В ответе не должно быть дубликатов. Например, тройка [1, -1, 0] и [0, 1, -1] — это один и тот же набор,
поэтому в ответе должна быть только одна из них.
"""
from typing import List

test_data = (
    # input, output
    ([-1,0,1,2,-1,-4], [[-1,-1,2],[-1,0,1]]),
    # ([0,1,1], []),
    # ([0,0,0], [[0,0,0]]),
)

def three_sum(nums: List[int]) -> List[List[int]]:
    """
    Будем фиксировать одно число, а остальные подбирать методов двух указателей во вложенном цикле.
    Массив для двух указателей должен быть отсортирован.
    """
    nums.sort()     # Сортируем массив, чтобы применить метод двух указателей
    sums = []   # Здесь будем хранить результаты
    len_nums = len(nums)    # Заранее кладем длину массива в переменную

    for fix_num_index in range(len_nums - 2):

        # Пропускаем дубликаты для фиксированного числа. То есть если прошлое число в массиве такое же как итерируемое,
        # то значит мы его уже брали и, если для него были подходящие под условия задачи числа в массиве, то они уже в
        # результате и нет смысла повторно их доставать.
        # fix_num_index > 0 - проверяет, что это не самая первая итерация, чтобы не упасть с ошибкой во втором условии
        # nums[fix_num_index] == nums[fix_num_index - 1] - проверяет, что предыдущее число не такое же, как итерируемое
        if fix_num_index > 0 and nums[fix_num_index] == nums[fix_num_index - 1]:
            continue

        # Применяем метод двух указателей
        # Левый указатель - это элемент массива, который идет за тем, что мы определили в качестве фиксированного
        # Правый - конец массива
        left, right = fix_num_index + 1, len_nums - 1

        # Пока два указателя не встретились, крутим цикл
        while left < right:
            total = nums[fix_num_index] + nums[left] + nums[right]

            # Нашли искомое
            if total == 0:
                sums.append([nums[fix_num_index], nums[left], nums[right]])

                # Пропускаем дубликаты для left: так как мы только что уже использовали число, то оно не может
                # повторяться в остальных вариантах комбинации чисел, дающих в сумме ноль. Поэтому мы сдвигаемся вправо
                # по массиву, пока не увидим, что следующее, за left число массива, отличается от left.
                # Мы ставим индекс left за одну позицию ДО того числа, которое не является дубликатом,
                # потому что передвинем указатель на то число, что нам нужно ниже, после while циклом,
                # которые должны "переступить" дубликаты.
                while (
                        left < right     # Цикл крутится, пока два указателя не встретятся
                       and nums[left] == nums[left + 1]     # И пока следующее число в массиве == итерируемому
                ):
                    left += 1

                # Тоже самое для указателя справа, однако его двигаем по той же логике, но от конца к началу массива
                while (
                    left < right
                    and nums[right] == nums[right - 1]
                ):
                    right -= 1

                # Теперь устанавливаем индексы указателям так, чтобы они "встали" на то следующее число массива,
                # которое отличается от уже использованного в решении
                left += 1
                right -= 1

            elif total < 0:
                left += 1
            else:
                right -= 1
    return sums


for i_arr, i_res in test_data:
    result = three_sum(i_arr)
    if result == i_res: print("ВЕРНО", i_arr, i_res, result)
    else: print("NOT ВЕРНО", i_arr, i_res, result)