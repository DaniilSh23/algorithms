"""
LeetCode #70 Climbing Stairs.
Нужен код, который будет посчитать сколько есть способов добраться до N-й ступеньке на лестнице, если за один шаг мы
можем подниматься либо на одну, либо на 2 ступеньки.
"""


def climb_stairs(stairs_numb: int) -> int:
    """
    Принимаем число ступенек и считаем с применением динамического программирования число возможных вариантов
    подняться по ступенькам.
    ...
    За всю историю человечества никому нахуй не надо было считать сколько вариантов есть подняться по лестнице,
    все просто брали и поднимались, даже до изобретения лестницы.
    Прикиньте, как в звездных войнах:
    Давным давно, в далекой - далекой галактике некие долбаебы изобретали программу, которая расскажет им как подняться
    по лестнице.
    Ну ладно, может они придумывали робота-гуманойда и этот хрен должен был наиболее оптимально подниматься по лестнице.
    Хотя нахуй закладывать в его софт логику расчета вариантов подъема по лестнице, у него должен быть просто алгоритм,
    как взобраться на возвышенность и не важно, что это ступеньки или горный склон с разбросанными природой камнями.

    Короче, хуйней какой-то занимаемся, товарищи программисты.
    """
    # Определяем переменные, как предыдущий шаг и текущий шаг.
    # То есть сколько у нас было вариантов подняться до предыдущей ступеньки и сколько до текущей ступеньки.
    # И да, оба эти варианта на старте равны одному. То есть у нас был пока что только один вариант подняться.
    # Ну если прикинуть на практике, то если ступенька одна, то у нас есть только один вариант на нее подняться,
    # вариант шагнуть на две ступеньки, когда задана одна не подходит, мы ведь переступим через нее.
    prev_step, current_step = 1, 1

    # Крутим столько итераций, сколько у нас ступенек
    for _ in range(stairs_numb):
        # На каждой итерации берем ранее рассчитанное значение числа вариантов подняться на прошлую ступеньку и
        # прибавляем к нему текущее число вариантов - это даст новое значение числа вариантов подняться на следующую
        # ступеньку. И мы такие сразу говорим, что число вариантов подняться на следующую ступеньку - это теперь число
        # вариантов для текущей ступеньки, а предыдущее число вариантов стало текущим.
        # Фуух... сам сказал че понял, очень запутанная хуйня для ease задачки.
        # Ну короче общая формула такая:
        # число вариантов подняться на новую ступеньку = числу вариантов прошлой + число вариантов позапрошлой.
        # Снова нихуя не понятно, понимаю. Каждая новая ступенька зависит от двух предыдущих, потому что мы можем
        # шагать либо на одну, либо на две ступеньки за раз...
        # Если бы могли шагать на одну, на две, или на три ступени за раз, то каждая новая ступенька зависила бы от
        # трех предыдущих. Короче, как это связано - хуй его знает, просто принимает как данность и юзаем.
        # В данном случае две ступени и тут применимы числа Фибоначчи: каждое следующее значение зависит от суммы двух
        # предыдущих. Тут можно было бы написать код вот так, было бы понятнее:
        #
        # new_step = current_step + prev_step
        # prev_step = current_step
        # current_step = new_step
        #
        # То есть мы сперва посчитали новое значение, затем изменили предыдущие, чтобы двинуться дальше.
        # В коде ниже сразу нахуй все в одну строку. Сэкономили блядь ячейку памяти для целого числа, у нас же их
        # нынче дефицит, роскошь блядь ячейки памяти эти.
        # По интернету люди сиськи-письки терабайтами в милисекунду перегоняют между собой, но мы-то блядь бережливые.
        prev_step, current_step = current_step, prev_step + current_step
    return prev_step
