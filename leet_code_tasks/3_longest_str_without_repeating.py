"""
Нужно найти самую длинную подстроку, где все символы уникальны (то есть ни один символ не повторяется в подстроке,
не обязательно только рядом стоящие).
"""

test_data = (
    # Входные данные, верные ответы
    ("abcabcbb", ("abc", "bca", "cab")),
    ("bbbbb", ("b",)),
    ("pwwkew", ("wke",)),
    ("abcabcbbabcde", ("abcde",)),
    ("x", ("x",)),
    ("xzx", ("xz",)),
)


def longest_str_without_repeating(string: str) -> int:
    """
    Функция для поиска самой длинной подстроки без повторения символов.
    Будем использовать подход "слайд-окно".
    """
    if not string:
        return 0

    char_set = set()  # хранит символы текущего окна
    left = 0  # левая граница
    max_length = 0  # ответ

    for right in range(len(string)):    # Цикл будет двигать правую границу

        # Когда спотыкаемся о дублирующийся символ, в цикле подвигаем левую границу,
        # пока в нашем отобранном множестве не останется дублирующихся символов.
        while string[right] in char_set:
            char_set.remove(string[left])   # Удаляем левый символ из нашего множества
            left += 1   # Сдвигаем левую границу

        # Добавляем новый символ, но только тогда, когда добились того, что во множестве нет дублей для него.
        char_set.add(string[right])

        # Обновляем максимум
        max_length = max(max_length, len(char_set))

    return max_length


def longest_str_without_repeating_last_seen(s: str) -> int:
    """
    Функция для поиска самой длинной подстроки без повторения символов.
    Будем использовать подход "слайд-окно".
    Используем метод last_seen.

    Пояснения:
        last_seen[char] — показывает, где в последний раз видели символ.
        left — с какого индекса начинается текущее окно
        right — где окно заканчивается
        Если last_seen[char] >= left → символ внутри окна
        last_seen[char] никогда не может быть > right (он получается на основе итераций цикла)
    """
    last_seen = {}  # {символ: последний индекс}

    left = 0  # левая граница окна
    max_length = 0

    for right in range(len(s)):
        char = s[right]

        # Пробуем понять есть ли итерируемый символ в просматриваемом окне (часть строки от left до right)
        # Если итерируемый символ есть в словаре, где храним все символы и его последний индекс ≥ left
        # (то есть это не символ, который остался в словаре после того, как окно просмотра уже сдвинулось)
        if char in last_seen and last_seen[char] >= left:
            left = last_seen[char] + 1  # сдвигаем окно: left ЗА дубликат (mn|abXdX|ef -> mnabX|dX|ef)

        # Обновляем последний индекс.
        # То есть нам нужно поставить left за дублирующий символ(X), который ранее выявили (это мы сделали выше для left).
        # А здесь мы выставляем новому символу(X), на который наткнулись в этой итерации, правую границу окна, как индекс
        # (mn|abXdX|ef -> mnabX|dX|ef)
        last_seen[char] = right

        # Обновляем максимум
        max_length = max(max_length, right - left + 1)

    return max_length

for i_txt, expected_results in test_data:
    result = longest_str_without_repeating_last_seen(i_txt)
    print(i_txt, result)


