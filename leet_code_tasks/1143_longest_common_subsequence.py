"""
LeetCode # 1143 "Longest Common Subsequence"
"""


def longest_common_subsequence(text1: str, text2: str) -> int:
    """
    Решение задачи через DP
    «Наиболее длинная общая подпоследовательность» - символы, которые есть в обоих строках, не обязательно идут друг
    за другом, но обязательно не должен нарушаться порядок их следования
    """
    # Определяем длины обоих строк
    txt1_len, txt2_len = len(text1), len(text2)

    # Создаем двумерный массив он будет представлять собой таблицу в которой каждая строка - это пустая строка
    # и дальше остальные символы из text1, а колонки - это тоже пустая строка и остальные символы из text2.
    # Всю таблицу сперва заполняем нулями.
    lcs_length_table = [[0] * (txt1_len + 1) for _ in range(txt2_len + 1)]

    # Итерируемся по созданной нами таблице и начинаем со второго элемента, так как первыми у нас пустые строки
    for row_indx in range(1, txt2_len + 1):
        for col_indx in range(1, txt1_len + 1):

            # Если символы равны
            if text1[row_indx - 1] == text2[col_indx - 1]:
                # Мы берем прошлую длину (хуй знаю как это работает), но типо достаем значение прошлых общих символов
                # по диагонали вверх назад в таблице. Да, мне тоже нихуя не понятно почему так.
                # Основной вопрос почему мы плюсуем значение к значению из таблицы, которое расположено левее выше,
                # а не к максимальному для первой или второй строки.
                lcs_length_table[row_indx][col_indx] = lcs_length_table[row_indx - 1][col_indx - 1] + 1

            # Если символы не равны
            else:
                # Мы берем большее значение: либо строкой выше, либо колонкой левее. Что это значит ?
                # Если строкой выше, то мы берем посчитанное число LCS для первой строки.
                # Если колонкой левее, то мы берем посчитанное число LCS для второй строки.
                # И вот какая из строк дает максимальное из значений, то мы и подставляем в поле таблицы.
                # Нихуя не понятно? Да, мне тоже 50/50. Самый важный вопрос: почему так работает?
                lcs_length_table[row_indx][col_indx] = max(
                    lcs_length_table[row_indx - 1][col_indx],
                    lcs_length_table[row_indx][col_indx - 1],
                )

    # Возвращаем самое крайнее значение таблицы
    return lcs_length_table[txt2_len][txt1_len]