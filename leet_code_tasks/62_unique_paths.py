"""
LeetCode #62 Unique Paths
"""


def unique_paths(m: int, n: int) -> int:
    """
    Решаем через DP
    :param m: высота сетки
    :param n: ширина сетки
    :return: кол-во путей, которыми можно дойти из верхней левой к нижней правой клетке.
    """
    # С помощью DP наша задача посчитать кол-во путей, которыми можно добраться до каждой клетки в сетке
    # и так дойти до правой нижней клетки.
    # Для этого мы создаем двумерный массив, который будет построен на основе нашей сетки.
    # Этот массив будет хранить в каждой клетке число путей, как можно добраться до данной клетки.
    # Первую строку и первую колонку сетки мы заполняем единицами - это значит, что есть только один путь добраться
    # до каждой клетки в первой строке и первой колонке. Ходить мы можем только вниз и вправо, поэтому есть только один
    # путь добраться до любой клетки в первой строке и в первой колонке.
    paths = [[1] * n for _ in range(m)]

    # Обходим каждую клетку сетки, наша задача рассчитать и установить в наш paths число путей, которыми можно
    # добраться до той или иной клетки. В итерациях мы не обходим первую строку и первую колонку - начинаем со вторых.
    for row in range(1, m):
        for col in range(1, n):
            # Число путей к клетке = сумма из клетки сверху плюс сумма из клетки слева.
            # Короче, на ту или иную клетку мы можем зайти либо слева, либо сверху.
            # На прошлых клетках (клетка сверху и клетка слева) у нас уже рассчитаны суммы путей для этих самых
            # прошлых клеток, поэтому сложив число путей к прошлым клеткам, мы получим число путей к итерируемой клетке.
            paths[row][col] = paths[row - 1][col] + paths[row][col - 1]

    # Выкидываем из функции расчет для нижней правой клетки
    return paths[m - 1][n - 1]