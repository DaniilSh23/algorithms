"""
LeetCode # 994 "Rotting Oranges"
"""
from collections import deque
from typing import List

test_data = (
    # grid, result
    (
        [
            [2,1,1],
            [1,1,0],
            [0,1,1],
        ],
        4,
    ),
    (
        [
            [2,1,1],
            [0,1,1],
            [1,0,1],
        ],
        -1,
    ),
    (
        [
            [0,2],
        ],
        0,
    )
)


def oranges_rotting(grid: List[List[int]]) -> int:
    """
    Применяем BFS
    """
    rows_numb, cols_numb = len(grid), len(grid[0])  # Размеры сетки (строки и колонки)
    queue = deque()     # Очередь для хранения гнилых апельсинов
    fresh_oranges = 0   # Счетчик кол-ва свежих апельсинов
    minutes = 0     # Сколько потрачено минут для того, чтобы все апельсины сгнили

    # Предварительно собираем координаты гнилых фруктов и количество свежих. Для этого надо обойти всю сетку
    for i_row in range(rows_numb):
        for i_col in range(cols_numb):

            # Проверяем встретился ли нам гнилой фрукт
            if grid[i_row][i_col] == 2:
                queue.append((i_row, i_col))
                continue

            # Проверяем встретился ли свежий фрукт
            elif grid[i_row][i_col] == 1:
                fresh_oranges += 1

    # Если изначально нет свежих апельсинов, то возвращаем результат: чтоб все сгнило нужно 0 минут
    if fresh_oranges == 0: return minutes

    # Дальше нужно имитировать гниение апельсинов
    # Крутим цикл, пока в очереди есть элементы. Внутри цикла while очередь будет пополняться при наличии апельсинов,
    # поэтому она закончится, когда уже не останется гнилых (нет гнилых значит ничего не может заразить свежие)
    # Назовем этот цикл "цикл заражения апельсинов"
    while queue:

        # Выполняем только то кол-во итераций в цикле for, сколько есть гнилых апельсинов в очереди на данный момент.
        # Ниже гнилые апельсины будут добавляться в очередь, но это уже будет следующий шаг распространения гнили.
        # Для каждого шага распространения гнили на соседние апельсины необходима одна минута.
        # Таким образом мы в данном цикле выполняем по одной итерации для каждого уже гнилого апельсина, а ниже будем
        # заражать его соседей и пополнять очередь новыми гнилыми апельсинами, но чтобы "вновь обращенные" начали
        # заражать своих соседей должна пройти 1 минута. Поэтому данный цикл делает так, чтобы мы заразили только
        # апельсины в рамках данной минуты.
        # Эту задачу надо не про апельсины делать, а про зомбаков - было бы интереснее.
        for _ in range(len(queue)):

            # Достаем один зараженный апельсин (зомбак-апельсин/апель-зомб/зомбапель)
            current_row, current_col = queue.popleft()

            # Определяем соседние ячейки зараженного апельсина
            neighbors = (
                # Слева: строка текущая, колонка не должна уйти левее карты
                (current_row, current_col - 1 if current_col > 0 else None),
                # Правее: строка текущая, колонка не должна уйти правее карты
                (current_row, current_col + 1 if current_col < cols_numb - 1 else None),
                # Выше: строка не должна уйти выше карты, колонка текущая
                (current_row - 1 if current_row > 0 else None, current_col),
                # Ниже: строка не должна уйти ниже карты, колонка текущая
                (current_row + 1 if current_row < rows_numb - 1 else None, current_col),
            )

            # Обходим соседние ячейки для заражения
            for neighbor_row, neighbor_col in neighbors:
                if (
                    # Ячейка не выходит за границы сетки
                    neighbor_row is not None and neighbor_col is not None
                    # На данной ячейке свежий апельсин
                    and grid[neighbor_row][neighbor_col] == 1
                ):
                    # Заражаем свежий апельсин
                    grid[neighbor_row][neighbor_col] = 2
                    # Закидываем его в очередь зараженных
                    queue.append((neighbor_row, neighbor_col))
                    # Отнимаем кол-во свежих апельсинов
                    fresh_oranges -= 1

        # Добавляем минуту в конце одной стадии заражения
        minutes += 1

    # Если остался хотя бы один свежий апельсин, мы должны вернуть -1 по условию,
    # иначе возвращаем кол-во минут, потраченных на заражение. Также при выводе результатов от кол-ва минут отнимаем 1,
    # потому что крайняя итерация будет выполнена, но на ней уже не будет заражений. Крайняя итерация выполняется,
    # потому что мы добавляем в очередь последние зараженные апельсины и "цикл заражения" должен прокрутиться и
    # проверить есть ли им кого заразить. Но заражать им некого, а минута плюсуется.
    return -1 if fresh_oranges > 0 else minutes - 1


for i_grid, i_result in test_data:
    result = oranges_rotting(i_grid)
    if result == i_result: print("ВЕРНО", i_grid, i_result, result)
    else: print("NOT ВЕРНО", i_grid, i_result, result)
