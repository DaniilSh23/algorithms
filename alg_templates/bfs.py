"""
BFS (Поиск в ширину)
Условия: "Кратчайший путь в графе/сетке"
Задачи LeetCode: #1091 (Shortest Path in Binary Matrix), #994 (Rotting Oranges), #200 (Islands)
"""

from collections import deque
q = deque([(start, 0)])  # (позиция, шаг)
visited = {start}

while q:
    pos, dist = q.popleft()
    if pos == target:
        return dist
    for next_pos in neighbors(pos):
        if next_pos not in visited:
            visited.add(next_pos)
            q.append((next_pos, dist + 1))

"""
Хз насколько верно иллюстрирует подход код выше, его сгенерила нейронка.

Вот общая логика, которую я обсудил с нейронкой, для алгоритма поиска в ширину BFS:

Да, вы абсолютно правильно описали основную **логику работы BFS** на примере поиска пути в матрице:

- **Вы стартуете из начальной точки (например, клетка 0),** находите все возможные ходы из неё (например, четыре 
стороны или восемь направлений).
- **Переходите на первый шаг по всем этим вариантам:** добавляете всех найденных "соседей" в список для следующего шага.
- Затем **одновременно берёте все клетки текущего шага** (то есть весь "уровень"), смотрите для каждой из них соседей 
для следующего шага.  
- Повторяете этот процесс: на каждом шаге работаете со всеми клетками одного "уровня" — это означает, что если где-то 
на очередном шаге встретится финиш, значит, до него было минимальное* возможное число шагов от старта.
- Как только на каком-то из путей достигли финиша — это и будет **самый короткий путь** (если шаги одинаковой стоимости).

**Ключевой момент BFS:**  
Вы "расширяетесь" по всем направлениям, не углубляясь в какой-то конкретный путь, а навстречу сразу большим количеством 
маленьких шагов. Как только один из вариантов достиг цели — можно быть уверенным, что это самый минимальный путь в стандартных задачах.

**Именно так работает BFS в задачах наподобие "Shortest Path in Binary Matrix" на LeetCode.**

[1](https://leetcode.com/problems/shortest-path-in-binary-matrix/description/)
"""