"""
DP (Динамическое программирование)
Условия: "Оптимизация с перекрывающимися подзадачами"
Задачи LeetCode: #70 (Climbing Stairs), #198 (House Robber), #62 (Unique Paths), #1143 (LCS)
"""

# 1D DP
dp = [0] * len(arr)
for i in range(1, len(arr)):
    dp[i] = max(dp[i-1], dp[i-2] + arr[i])  # House Robber


# 2D DP
dp = [[0] * n for _ in range(m)]
for i in range(m):
    for j in range(n):
        dp[i][j] = max(dp[i-1][j], dp[i][j-1])  # Unique Paths

"""
Общий шаблон для DP:

1) Определить подзадачи:
Нужно понять, как разбить задачу на более простые части, которые можно решить отдельно и комбинировать.

2) Сформулировать состояние:
Обычно это какая-то структура (dp–массив, кортеж), которая хранит результат для части задачи 
(например: "максимальная сумма для первых i элементов").

3) Придумать переход (рекуррентную формулу):
Это главный шаг: как получить ответ для большой задачи через ответы для меньших задач. 
Например:
dp[i]=max(dp[i−1],dp[i−2]+nums[i]) — для House Robber
dp[i][j]=dp[i−1][j]+dp[i][j−1] — для комбинаторных (как в задачах про пути на решётке)

4) Базовые случаи (инициализация):
Всегда прописываются значения для начала (например, пустой массив, один элемент).

5) Последовательный перебор:
Обычно цикл/двойной цикл — мы вычисляем значения dp по порядку.

Ниже базовый пример псевдокода на python для DP:
"""

# dp[i] хранит ответ для задачи до i-го элемента
dp = [базовые значения]

for i in range(1, N):  # обычно начинаем с одного из базовых случаев
    dp[i] = ...  # тут надо прописать связь с меньшими задачами

print(dp[-1])  # или другой нужный элемент

"""
Типичные признаки задачи на DP:
- Можно разбить на "подзадачи"
- Есть повторяющиеся вычисления для похожих входов
- Важно помнить результат и не считать его несколько раз

Итог:
DP — это всегда поиск:
- что запоминать
- как использовать уже посчитанное
- как переходить от малого к большому
"""